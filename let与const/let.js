// {
//   let a = 10;
//   var b = 1;
// }
// console.log(a) // a in not defined
// console.log(b) // 可正常输出 打印 结果为 1 

// 于是乎就引出了一个概念： {} => 块级作用域，也就是说这里面包裹住的东西为一块作用域。

// -------------------------------分界线------------------------------------

// 然后我们再来看看for中的i
// 一般我们写for为这样的。
// for (var i = 0; i < 10; i++) {
//   // console.log(i) // 输出 1 =》 9
// }
// console.log(i) // 输出 10

// 我们能看见,在for外面也可以拿到i 并且再最后 i 还会被增长为 10 ，很显然，这不是我们想要的
// 而使用let 就会在for循环中形成一个块级作用域 
// for (let i = 0; i < 10; i++) {
//   console.log(i) // 这里会正常输出 1 => 9
// }
// console.log(i) // 而这里会报(i is not defined)
// 也就是说 使用let 会实现块级作用域，将里面所创建的变量死死的包住，不会让他影响到外面的变量

// -------------------------------分界线------------------------------------
// 在看看下面的for
// for (let i = 0; i < 3; i++) {
//   let i = 'abc';
//   console.log(i); // 'abc' * 3
// }

// 我们可以看见在 for中定义了i 而在 {} 中 我们也定义了 i 但是这两个 i 因使用了 let 而不会相互影响
// 这就是let中的for循环一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

// -------------------------------分界线------------------------------------

// 变量提升
// 相信大家对于变量提升都会有一定的了解，这里就不说，这里使用let 可以避免变量提升的情况

// // var 的情况
// console.log(foo); // 输出undefined
// var foo = 2;

// // let 的情况
// console.log(bar); // 报错ReferenceError
// let bar = 2;

// -------------------------------分界线------------------------------------

// 暂时性死区
// var tmp = 123;

// if (true) {
//   tmp = 'abc'; // 报错，因为在 {} 中，已经使用let tmp，所以外面的 tmp 不会影响到里面的 tmp,因为let 不会存在变量提升的问题，所以报错
//   let tmp;
// }

// 有些死区会比较隐蔽，不容易发现

// function bar(x = y, y = 2) {
//   return [x, y];
// }

// bar(); // 报错

// 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。

// function bar(x = 2, y = x) {
//   return [x, y];
// }
// bar(); // [2, 2]

// -------------------------------分界线------------------------------------

// let不允许在相同作用域内，重复声明同一个变量。

// // 报错
// function func() {
//   let a = 10;
//   var a = 1;
// }

// // 报错
// function func() {
//   let a = 10;
//   let a = 1;
// }

// -------------------------------分界线------------------------------------

// ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。

// 第一种场景
// var tmp = new Date();

// function f() {
//   console.log(tmp);
//   if (false) {
//     var tmp = 'hello world'; // 因为没有块级作用域，所以 条件不成立的情况下，var tmp 还是会在函数作用域里中变量提升
//   }
// }

// f(); // undefined

// 第二种场景
// var s = 'hello';

// for (var i = 0; i < s.length; i++) {
//   console.log(s[i]);
// }

// console.log(i); // 5